# object-oriented-Game-Programming
OBJECT ORIENTED PROJECT Game Mechanics: Map: In this game there’s a map that holds every object’s position. The map printed on to the console everytime and it’ll be updated everytime player moves. You can use system(“CLS”); function ,if you’re using Windows OS, between your update operations. So it’d seem like player actually moved instead of printing the whole map again. Game should create the map from a text file. This text file will be provided later on. Work with a temporary text file for now. In this text file the objects signs’ and position will be given. Your program should read these and create the map according to this information. You can use ‘F’ for finish point, ‘E’ for enemy, ‘-‘ for empty object, ‘G’ for gold positions. Player will always start from the bottom left corner of the map.  The map is circular, which means if the player tries to move up when it is on the top, it should be teleported to the bottom. It works for left-right, right-left, top-bottom, bottom-top ways. If there’s nothing on a specific position it’ll be displayed with ‘-‘, if the object is not in the player’s neighbourhood it’ll be displayed with ‘#’ sign (Fog of war mechanic).Look figure 3 for more details. Player Movement: Player is the protagonist in this game. Player is represented with the ‘P’ sign on the map. Player can choose to move up, down, left or right in the map. Your program must ask everytime if the player wants to move up, down, lef tor right. In that menu you can take 6 inputs. 1 for moving up, 2 for moving down, 3 for moving right, 4 for moving left, 5 to print player’s information 6 to exit from the game. Figure 2 shows the print information input’s result:   The player will be moved according to the input received from the user. You should check if the player can move to that position, if it can’t player must stay in its position. Example: If there’s an enemy in a way you can’t move immediately. First you must defeat the enemy and only then you can move to that position. If there’s a gold in the way player moves and collect’s it. If the finish point is on the way player moves and the game finishes after that. These will be explained later on. Look figure 3 for more details about the movement mechanic. Fog of War Mechanic: With this mechanic player can only see its immediate neighbours. All other map information will be displayed with ‘#’ sign. That means these objects are not visible to the player. You should check player’s immediate neighbours after moving the player. So you can update the immediate neighbours after every movement of the player. Ex: Let’s assume player is on the (5,5) location, (5,4), (5,6), (4,4), (4,5), (4,6), (6,4), (6,5), (6,6) will be visible to the player. Look figure 3 for more details.      Collecting Gold Mechanic: Player can collect golds in this game. Gold objects are represented with the ‘G’ sign on the map. Golds are created from the file as explained at map mechanic. Golds values are randomized, this will be explained later on. In order to collect a gold player must move to the gold’s position. After that you should display how much gold is collected by the player. Gold amount should be transferred to the player’s currency. Lastly, the gold object that the player has collected, must be removed from the map. Collected golds are erased from the data structure. This is an important task don’t forget to implement this. Look for figure 4 for visualization. .  Fighting Mechanic: The player can fight with the enemies. In order to fight the player should move on to the enemy. The game asks if the player wants to fight the enemy or not Y/N. If the user chooses not to fight (N) player should stay on its previous position. If the user chooses to fight (Y) game should display the enemies information first, and then ask for inputs untill player or enemy dies. It’s a turn based fight mechanic. Player can attack the enemy with the input of 1 or can drink potion with the input of 2. After each input enemy performs an action. Enemy can drink potion or attack the player.  Attacking Mechanic: If the player chooses to attack the enemy by entering 1, player’s damage should be sent to the TakeDamage(damage) function of the enemy object. Same thing happens fort he enemy’s attack action. Player and enemies have a critical chance. Create a random number and check if the attack is critical or not before applying damage to both sides. If an attack is critical, double the damage, if it’s not apply normal damage. Player and enemy both have armors. Apply (damage-armor) amount of damage to the both sides. If any of the sides dies return from this function with the appropriate value and continue OR end the game according to the value. Drinking Potion: Both player and the enemy have a certain amount of potions at start and they can use these potions in the fight mechanic. Player can drink the potion if the user presses 2 on the fight and have atleast 1 potion. Enemy have a chance to drink a potion if it has atleast 1 potion. This chance increases proportionally with its missing health value. Ex: If the enemies health is full it’s drinking potion chance is %0, if it’s health is %20 drinking potion chance is %80. Player has 5 potion and enemies have 1 potion at start. Look for Values title for the default values.  Drinking a potion restores player/enemy health by 500. But they have a maximum health values. Their health can’t reach this value. Ex: If the player’s max health (starting health) is 1000 and it’s current health is 700 and the user chooses to drink a potion: player’s health restores up to 1000. 200 hp will not be added, 200 hp will go to waste. Taking a Kill: Player and the enemy can kill their targets. If the player dies game ends. If player kills it’s enemy, a certain amount of experience point is given to the player. Experience amount is stored in the enemy object. This is a randomized value, look for the values title for more information. Player has a chance to recieve a potion after killing an enemy, this drop chance also is a randomized value. Look at figure 5 to visualize these mechanics.  Leveling Up: After killing its target player recieves a certain amount of experience. This experience can cause the player to level up. Player has a toLevelUp value (Look for values title), if player’s experience exceeds this value player levels up. You should print when this happens. After leveling up player’s stats are updated. ToLevelUp value is updated according to a formula. Ex: Let’s say the player has 800 experience and needed experience for leveling up is 1000. Player kills an enemy and recieves 500 experience. Player’s experience now setted to 300 (800+500%1000) and toLevelUp value setted to 2000 (Look for values title). Look at figure 5. Figure 5 represents the taking 500 experience after killing the enemy and displaying player’s stats after killing. Look at the updated values of the player (experience and needed experience).
